#include "VBAPRenderer.hpp"
#include <cmath>
#include <iostream>

VBAPRenderer::VBAPRenderer(const SpeakerLayoutData &layout,
                           const SpatialData &spatial,
                           const std::map<std::string, MonoWavData> &sources)
    : mLayout(layout), mSpatial(spatial), mSources(sources),
      mSpeakers(), mVBAP(mSpeakers, true)
{
    // Convert our layout data into AlloLib Speakers vector
    for (const auto &spk : layout.speakers) {
        mSpeakers.emplace_back(al::Speaker(
            spk.deviceChannel,
            spk.azimuth,
            spk.elevation,
            0, // group
            spk.radius
        ));
    }
    
    // Reinitialize VBAP with the populated speakers
    mVBAP = al::Vbap(mSpeakers, true);
    mVBAP.compile();
}

al::Vec3f VBAPRenderer::interpolateDir(const std::vector<Keyframe> &kfs, double t) {

    if (kfs.size() == 1) {
        return al::Vec3f(kfs[0].x, kfs[0].y, kfs[0].z).normalize();
    }

    Keyframe k1, k2;

    for (int i = 0; i < kfs.size() - 1; i++) {
        if (t >= kfs[i].time && t <= kfs[i+1].time) {
            k1 = kfs[i];
            k2 = kfs[i+1];
            break;
        }
    }

    double u = (t - k1.time) / (k2.time - k1.time);

    al::Vec3f v(
        (1-u)*k1.x + u*k2.x,
        (1-u)*k1.y + u*k2.y,
        (1-u)*k1.z + u*k2.z
    );
    v.normalize();
    return v;
}

MultiWavData VBAPRenderer::render() {

    int sr = mSpatial.sampleRate;
    int numSpeakers = mLayout.speakers.size();

    // Determine output length = longest source
    size_t totalSamples = 0;
    for (auto &[name, wav] : mSources) {
        totalSamples = std::max(totalSamples, wav.samples.size());
    }

    std::cout << "Total samples: " << totalSamples << "\n";
    std::cout << "Sample rate: " << sr << "\n";
    std::cout << "Duration: " << (double)totalSamples / sr << " seconds\n";
    std::cout << "Number of speakers: " << numSpeakers << "\n";
    std::cout << "Number of sources: " << mSources.size() << "\n";

    MultiWavData out;
    out.sampleRate = sr;
    out.channels = numSpeakers;
    out.samples.resize(numSpeakers);
    for (auto &c : out.samples) c.resize(totalSamples, 0.0f);

    // Setup AudioIOData with proper buffer size
    const int bufferSize = 512;
    al::AudioIOData audioIO;
    audioIO.framesPerBuffer(bufferSize);
    audioIO.framesPerSecond(sr);
    audioIO.channelsIn(0);
    audioIO.channelsOut(numSpeakers);
    
    // Process in blocks
    std::vector<float> sourceBuffer(bufferSize);
    
    int blocksProcessed = 0;
    for (size_t blockStart = 0; blockStart < totalSamples; blockStart += bufferSize) {
        size_t blockEnd = std::min(totalSamples, blockStart + bufferSize);
        size_t blockLen = blockEnd - blockStart;
        
        if (blocksProcessed % 5000 == 0) {
            std::cout << "Processing block " << blocksProcessed << " (" 
                      << (100.0 * blockStart / totalSamples) << "%)\n";
        }
        blocksProcessed++;
        
        // Zero out audio buffers for this block
        audioIO.zeroOut();
        
        // Render each source for this block
        for (auto &[name, kfs] : mSpatial.sources) {
            const MonoWavData &src = mSources.at(name);
            
            // Fill source buffer for this block
            for (size_t i = 0; i < blockLen; i++) {
                size_t globalIdx = blockStart + i;
                sourceBuffer[i] = (globalIdx < src.samples.size()) ? src.samples[globalIdx] : 0.0f;
            }
            
            // Get position at the start of this block
            double timeSec = (double)blockStart / (double)sr;
            al::Vec3f dir = interpolateDir(kfs, timeSec);
            
            // Render this source's contribution (VBAP uses += so it accumulates)
            mVBAP.renderBuffer(audioIO, dir, sourceBuffer.data(), blockLen);
        }
        
        // Copy rendered audio to output
        audioIO.frame(0);
        for (size_t i = 0; i < blockLen; i++) {
            for (int ch = 0; ch < numSpeakers; ch++) {
                out.samples[ch][blockStart + i] = audioIO.out(ch, i);
            }
        }
    }
            if (blocksProcessed == 1) {
                float maxVal = 0;
                for (size_t i = 0; i < blockLen; i++) {
                    if (std::abs(sourceBuffer[i]) > maxVal) maxVal = std::abs(sourceBuffer[i]);
                }
                std::cout << "  Source " << name << ": max in buffer = " << maxVal 
                          << ", src size = " << src.samples.size() << "\n";
            }
            
            // Get position at the start of this block
            double timeSec = (double)blockStart / (double)sr;
            al::Vec3f dir = interpolateDir(kfs, timeSec);
            
            // Debug: check direction for first block
            if (blocksProcessed == 1) {
                std::cout << "  Dir for " << name << ": (" << dir.x << ", " << dir.y << ", " << dir.z << ")\n";
            }
            
            // Zero audioIO for this source
            audioIO.zeroOut();
            
            // Render this source's contribution
            mVBAP.renderBuffer(audioIO, dir, sourceBuffer.data(), blockLen);
            
            if (blockStart == 0 && name == mSpatial.sources.begin()->first) {
                std::cout << "After first renderBuffer, first 5 samples of ch 0:\n";
                audioIO.frame(0);
                for (int i = 0; i < 5; i++) {
                    std::cout << "  " << i << ": " << audioIO.out(0, i) << "\n";
                }
            }
            
            // Accumulate into our buffer
            audioIO.frame(0);
            for (size_t i = 0; i < blockLen; i++) {
                for (int ch = 0; ch < numSpeakers; ch++) {
                    accumBuffer[ch][i] += audioIO.out(ch, i);
                }
            }
        }
        
        // Copy accumulated audio to output
        for (size_t i = 0; i < blockLen; i++) {
            for (int ch = 0; ch < numSpeakers; ch++) {
                out.samples[ch][blockStart + i] = accumBuffer[ch][i];
            }
        }
    }
    
    std::cout << "Processed " << blocksProcessed << " blocks\n";
    std::cout << "Output has " << out.samples.size() << " channels\n";
    std::cout << "Channel 0 has " << out.samples[0].size() << " samples\n";

    return out;
}
